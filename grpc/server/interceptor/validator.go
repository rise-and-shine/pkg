package interceptor

import (
	"context"
	"errors"
	"github.com/code19m/errx"
	"github.com/code19m/pkg/grpc/server/wrgrpc"
	"google.golang.org/grpc"
)

// NewValidator creates an interceptor that validates incoming request messages.
// It checks if the request implements the ValidateAll method, which is typically
// generated by protobuf validation tools. If validation fails, it extracts field-level
// errors and returns them in a structured format.
//
// The validator interceptor has a priority of 500, placing it after higher-priority
// interceptors but before the actual handler is executed.
func NewValidator() wrgrpc.Interceptor {
	return wrgrpc.Interceptor{
		Priority: 500,
		Handler: func(
			ctx context.Context,
			req any,
			info *grpc.UnaryServerInfo,
			handler grpc.UnaryHandler,
		) (resp any, err error) {
			if validator, ok := req.(interface{ ValidateAll() error }); ok {
				if err := validator.ValidateAll(); err != nil {
					if fields := extractFieldErrors(err); len(fields) > 0 {
						return nil, errx.New("validation error",
							errx.WithType(errx.T_Validation),
							errx.WithCode("invalid_input_params"),
							errx.WithFields(fields),
						)
					}

					// if failed to extract field errors, return the generic error
					return nil, errx.Wrap(err, errx.WithType(errx.T_Validation), errx.WithCode("invalid_input_params"))
				}
			}
			return handler(ctx, req)
		},
	}
}

// extractFieldErrors extracts validation errors from a validation error object
// and returns them as a map of field names to error messages.
func extractFieldErrors(err error) errx.M {
	var fieldErrors errx.M = make(errx.M)
	extractNestedFieldErrors(err, "", fieldErrors)
	return fieldErrors
}

// extractNestedFieldErrors recursively extracts field-level validation errors,
// including those from nested objects, and adds them to the provided map.
func extractNestedFieldErrors(err error, prefix string, fieldErrors errx.M) {

	if all, ok := err.(interface{ AllErrors() []error }); ok {
		for _, errItem := range all.AllErrors() {
			var e interface {
				Field() string
				Reason() string
				Cause() error
			}

			if errors.As(errItem, &e) {
				fieldName := e.Field()
				if prefix != "" {
					fieldName = prefix + "." + fieldName
				}

				if _, ok := e.Cause().(interface{ AllErrors() []error }); ok && e.Cause() != nil {
					extractNestedFieldErrors(e.Cause(), fieldName, fieldErrors)
				} else {
					fieldErrors[fieldName] = e.Reason()
				}
			}
		}
	}

}
